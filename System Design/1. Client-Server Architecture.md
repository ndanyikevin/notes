
## 🧠 Definition: Client–Server Architecture

**Client–Server architecture** is a **design model** where software is divided into two main parts:

1. **Client** → The _frontend_ that requests services or data.
    
2. **Server** → The _backend_ that provides those services or data.
    

They communicate over a **network**, usually the internet, using standard protocols (like **HTTP**).

---

### 🧩 Example

Think of your school management app:

- **Client:** The React Native app used by teachers, students, and administrators.
    
- **Server:** The backend running on AWS (maybe using Node.js + Express + DynamoDB) that stores and processes the data.
    

Here’s what happens:

1. The **client** sends a request — e.g., “Get all students in Class 7A.”
    
2. The **server** receives the request, fetches the data from the database, and sends a response.
    
3. The **client** displays the data to the user.
    

---

### ⚙️ Typical Flow Diagram

```
[User] 
   ↓
[Client App / Browser / Mobile App]
   ↓  (HTTP Request)
[Server / API / Backend]
   ↓
[Database]
```

Response goes back up the same path.

---

## 🧱 Components of Client–Server Architecture

|Component|Description|Example|
|---|---|---|
|**Client**|User interface, runs on user’s device|Browser, React app, mobile app|
|**Server**|Central computer that stores and processes data|AWS EC2, Lambda, or API backend|
|**Database**|Stores the application data|DynamoDB, PostgreSQL, MySQL|
|**Network**|Connects client and server|Internet or local network|

---

## 🧰 Key Characteristics

|Feature|Description|
|---|---|
|**Separation of concerns**|Client handles UI; server handles logic & data.|
|**Scalability**|You can scale the server separately from the client.|
|**Security**|Data access can be controlled at the server level.|
|**Reusability**|Many clients (web, mobile, desktop) can use the same server.|

---

## 💡 Real-Life Example

When you log into **Gmail**:

- **Client:** The Gmail website or app.
    
- **Server:** Google’s mail servers (handle authentication, retrieve messages).
    
- **Flow:** App → Server → Database → Response → App displays emails.
    

---

## 🧮 Variants

1. **Two-tier architecture:** Client ↔ Server
    
    - Simple and direct (good for small apps).
        
2. **Three-tier architecture:** Client ↔ Application Server ↔ Database
    
    - More scalable and secure (used in most modern systems).
        
3. **N-tier architecture:** Adds layers like caching, API gateway, or load balancers for big systems.
    

---

Would you like me to show you **a small diagram or visual example** of a **client–server model** in your school management system (e.g., how teacher, mobile app, API, and database interact)?